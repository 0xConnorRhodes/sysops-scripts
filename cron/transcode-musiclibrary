#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "pyyaml",
# ]
# ///
"""
Script Requirements:
- As a user, I want to mirror the directory structure of '/zstore/music_library/music_library' to '/scary/music_library'.
- As a user, I want to maintain a configuration cache at '~/.local/share/music_library_transcode' that mirrors the source directory structure.
- As a user, I want to compare source 'meta.yml' files against the cached versions to detect changes.
- As a user, I want to identify "dirty scopes": directories where the 'meta.yml' has changed, necessitating a re-transcode of all files in that directory and its subdirectories.
- As a user, I want to transcode audio files if they are missing from the destination OR if they reside within a "dirty scope".
- As a user, I want to re-transcode all files in a directory (and subdirectories) if a '.changed' file exists in that directory, and then remove the '.changed' file after processing.
- As a user, I want to update the cache with the new 'meta.yml' files after processing is complete.
- As a user, I want to continue using 'ffmpeg' and 'mediainfo' for audio processing as previously defined.
"""

import os
import sys
import shutil
import subprocess
import json
import yaml
import filecmp
from pathlib import Path
from typing import Optional, Dict, Any, Set

# Configuration
SOURCE_ROOT = Path("/zstore/music_library/music_library")
DEST_ROOT = Path("/scary/music_library")
CACHE_ROOT = Path("~/.local/share/music_library_transcode").expanduser()

AUDIO_EXTENSIONS = {'.flac', '.m4a', '.aac', '.mp3', '.wav', '.ogg', '.alac'}
IMAGE_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.bmp'}

MAX_FILES_TO_PROCESS: Optional[int] = None # Set to None to process all files, or an integer for a specific limit

def get_transcode_settings(file_path: Path, root_path: Path) -> float:
    current_dir = file_path.parent
    
    search_path = current_dir
    dirs_to_check = []
    while search_path.is_relative_to(root_path):
        dirs_to_check.append(search_path)
        if search_path == root_path:
            break
        search_path = search_path.parent

    # 1. Specific File Override
    local_meta = current_dir / "meta.yml"
    if local_meta.exists():
        try:
            with open(local_meta, 'r') as f:
                data = yaml.safe_load(f) or {}
                if file_path.name in data:
                    if 'volume_reduce' in data[file_path.name]:
                        return float(data[file_path.name]['volume_reduce'])
        except Exception as e:
            print(f"Error reading {local_meta}: {e}", file=sys.stderr)

    # 2, 3, 4. Directory Defaults (Recursive)
    for d in dirs_to_check:
        meta_path = d / "meta.yml"
        if meta_path.exists():
            try:
                with open(meta_path, 'r') as f:
                    data = yaml.safe_load(f) or {}
                    if 'default' in data and 'volume_reduce' in data['default']:
                        return float(data['default']['volume_reduce'])
            except Exception as e:
                print(f"Error reading {meta_path}: {e}", file=sys.stderr)

    print(f"Error: Could not find a 'volume_reduce' setting in any meta.yml for the file: {file_path}", file=sys.stderr)
    print(f"Searched from {file_path.parent} up to {root_path}.", file=sys.stderr)
    sys.exit(1)

def get_file_metadata(file_path: Path) -> Dict[str, Any]:
    cmd = [
        "mediainfo",
        "--Output=JSON",
        str(file_path)
    ]
    # Suppress stderr to keep output clean
    result = subprocess.check_output(cmd, stderr=subprocess.DEVNULL)
    data = json.loads(result)
    
    media_track = next((t for t in data.get('media', {}).get('track', []) if t.get('@type') == 'Audio'), {})
    general_track = next((t for t in data.get('media', {}).get('track', []) if t.get('@type') == 'General'), {})

    bitrate = media_track.get('BitRate') or general_track.get('OverallBitRate') or "320000"
    if isinstance(bitrate, str):
        bitrate = ''.join(filter(str.isdigit, bitrate))

    return {
        "bitrate": int(bitrate),
        "format": general_track.get('Format', '').lower(),
        "audio_format": media_track.get('Format', '').lower()
    }

def transcode_file(source: Path, dest: Path, volume: float):
    meta = get_file_metadata(source)
    bitrate = meta['bitrate']
    fmt = meta['format']
    audio_fmt = meta['audio_format']

    codec = "copy"
    if "flac" in audio_fmt:
        codec = "flac"
    elif "aac" in audio_fmt or "mpeg-4" in fmt or "m4a" in source.suffix:
        codec = "aac"
    elif "mp3" in audio_fmt or "mpeg audio" in audio_fmt or source.suffix == ".mp3":
        codec = "libmp3lame"

    cmd = [
        "ffmpeg",
        "-y", 
        "-i", str(source),
        "-c:v", "copy",
        "-c:a", codec,
        "-b:a", str(bitrate),
        "-filter:a", f"volume={volume}",
        str(dest)
    ]

    try:
        subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print(f"[Encoded] {source.name} | Vol: {volume} | BR: {bitrate}")
    except subprocess.CalledProcessError:
        print(f"[Error] Failed to transcode: {source}", file=sys.stderr)

def identify_dirty_scopes() -> Set[Path]:
    """
    Compares Source meta.yml files with Cached meta.yml files.
    Also checks for .changed files which mark directories as needing re-transcode.
    Returns a set of Paths (directories) where the configuration has changed.
    """
    dirty_scopes = set()

    for root, _, files in os.walk(SOURCE_ROOT):
        root_path = Path(root)

        # Check for .changed files - these always make the directory dirty
        if ".changed" in files:
            dirty_scopes.add(root_path)
            print(f".changed file detected in: {root_path}")

        # Check for meta.yml changes
        if "meta.yml" in files:
            source_meta = root_path / "meta.yml"
            rel_path = root_path.relative_to(SOURCE_ROOT)
            cache_meta = CACHE_ROOT / rel_path / "meta.yml"

            # If cache doesn't exist, or content differs
            if not cache_meta.exists():
                dirty_scopes.add(root_path)
            else:
                if not filecmp.cmp(source_meta, cache_meta, shallow=False):
                    dirty_scopes.add(root_path)

    if dirty_scopes:
        print(f"Configuration changes detected in {len(dirty_scopes)} directories.")
    else:
        print("No configuration changes detected.")

    return dirty_scopes

def is_file_in_dirty_scope(file_path: Path, dirty_scopes: Set[Path]) -> bool:
    """
    Checks if a file resides in a directory (or subdirectory) of a changed meta.yml or .changed file.
    Because configuration cascades, a change in /Music affects /Music/Artist/Album.
    """
    current_check = file_path.parent
    while current_check.is_relative_to(SOURCE_ROOT):
        if current_check in dirty_scopes:
            return True
        if current_check == SOURCE_ROOT:
            break
        current_check = current_check.parent
    return False

def update_cache(dirty_scopes: Set[Path]):
    """
    Copies the new meta.yml files from Source to Cache for the identified dirty scopes.
    """
    print("Updating configuration cache...")
    for scope in dirty_scopes:
        rel_path = scope.relative_to(SOURCE_ROOT)
        dest_dir = CACHE_ROOT / rel_path
        dest_dir.mkdir(parents=True, exist_ok=True)

        source_meta = scope / "meta.yml"
        dest_meta = dest_dir / "meta.yml"

        if source_meta.exists():
            shutil.copy2(source_meta, dest_meta)

def cleanup_changed_files(dirty_scopes: Set[Path]):
    """
    Removes .changed files from directories that have been processed.
    """
    print("Cleaning up .changed files...")
    for scope in dirty_scopes:
        changed_file = scope / ".changed"
        if changed_file.exists():
            try:
                changed_file.unlink()
                print(f"Removed .changed file from: {scope}")
            except OSError as e:
                print(f"Warning: Could not remove .changed file from {scope}: {e}", file=sys.stderr)

def identify_dangling_files() -> Set[Path]:
    """
    Identifies AUDIO files in the destination that no longer exist in the source.
    Excludes _playlist folder and non-audio files from pruning.
    Returns a set of destination file paths that should be removed.
    """
    dangling_files = set()

    # Collect all source audio files only
    source_files = set()
    for root, dirs, files in os.walk(SOURCE_ROOT):
        # Skip _playlist folder at any level
        if '_playlist' in dirs:
            dirs.remove('_playlist')

        root_path = Path(root)
        for file_name in files:
            suffix = Path(file_name).suffix.lower()
            # Only track audio files for dangling file detection
            if suffix in AUDIO_EXTENSIONS:
                source_file = root_path / file_name
                rel_path = source_file.relative_to(SOURCE_ROOT)
                source_files.add(rel_path)

    # Check destination audio files against source
    for root, dirs, files in os.walk(DEST_ROOT):
        # Skip _playlist folder at any level
        if '_playlist' in dirs:
            dirs.remove('_playlist')

        root_path = Path(root)
        for file_name in files:
            dest_file = root_path / file_name
            suffix = Path(file_name).suffix.lower()

            # Only consider audio files for pruning
            if suffix not in AUDIO_EXTENSIONS:
                continue

            rel_path = dest_file.relative_to(DEST_ROOT)

            # Skip if corresponding source file exists
            if rel_path in source_files:
                continue

            # This audio file exists in destination but not in source
            dangling_files.add(dest_file)

    if dangling_files:
        print(f"Found {len(dangling_files)} dangling files in destination that will be removed.")
    else:
        print("No dangling files found in destination.")

    return dangling_files

def copy_playlist_folder():
    """
    Copies the _playlists folder from source to destination.
    Copies all m3u files but excludes the .git folder.
    Always overwrites the destination _playlists folder.
    """
    source_playlist = SOURCE_ROOT / "_playlists"
    dest_playlist = DEST_ROOT / "_playlists"

    if not source_playlist.exists():
        print("No _playlists folder found in source.")
        return

    print("Copying _playlists folder...")

    # Remove destination _playlists folder if it exists
    if dest_playlist.exists():
        try:
            shutil.rmtree(dest_playlist)
            print(f"Removed existing {dest_playlist.relative_to(DEST_ROOT)}")
        except OSError as e:
            print(f"Warning: Could not remove {dest_playlist}: {e}", file=sys.stderr)
            return

    # Create destination _playlists folder
    dest_playlist.mkdir(parents=True, exist_ok=True)

    # Copy all files and folders except .git
    for item in source_playlist.iterdir():
        if item.name == ".git":
            print(f"Skipping .git folder in _playlists")
            continue

        source_item = source_playlist / item.name
        dest_item = dest_playlist / item.name

        try:
            if source_item.is_dir():
                # Recursively copy directories
                shutil.copytree(source_item, dest_item)
                print(f"[Copied dir] {item.name}")
            else:
                # Copy files
                shutil.copy2(source_item, dest_item)
                print(f"[Copied file] {item.name}")
        except OSError as e:
            print(f"Warning: Could not copy {item.name}: {e}", file=sys.stderr)

def prune_dangling_files(dangling_files: Set[Path]):
    """
    Removes dangling files from the destination directory.
    """
    if not dangling_files:
        return

    print(f"Pruning {len(dangling_files)} dangling files from destination...")
    for file_path in dangling_files:
        try:
            file_path.unlink()
            print(f"[Removed] {file_path.relative_to(DEST_ROOT)}")
        except OSError as e:
            print(f"Warning: Could not remove {file_path}: {e}", file=sys.stderr)

    # Also remove empty directories
    print("Removing empty directories...")
    for root, dirs, files in os.walk(DEST_ROOT, topdown=False):
        root_path = Path(root)
        try:
            # Only remove if directory is empty
            if not os.listdir(root_path):
                root_path.rmdir()
                print(f"[Removed empty dir] {root_path.relative_to(DEST_ROOT)}")
        except OSError:
            # Directory not empty or other error, skip
            pass

def process_library():
    if not SOURCE_ROOT.exists():
        print(f"Source root {SOURCE_ROOT} does not exist.", file=sys.stderr)
        sys.exit(1)

    # 1. Detect Changes
    dirty_scopes = identify_dirty_scopes()

    # 2. Copy _playlists folder
    copy_playlist_folder()

    # 3. Identify and prune dangling files (files removed from source)
    dangling_files = identify_dangling_files()
    prune_dangling_files(dangling_files)

    # 4. Process Files
    processed_files_count = 0
    for root, _, files in os.walk(SOURCE_ROOT):
        root_path = Path(root)
        rel_path = root_path.relative_to(SOURCE_ROOT)
        dest_dir = DEST_ROOT / rel_path

        dest_dir.mkdir(parents=True, exist_ok=True)

        for file_name in files:
            if MAX_FILES_TO_PROCESS is not None and processed_files_count >= MAX_FILES_TO_PROCESS:
                print(f"Reached MAX_FILES_TO_PROCESS limit ({MAX_FILES_TO_PROCESS}). Stopping processing.")
                break

            source_file = root_path / file_name
            dest_file = dest_dir / file_name
            
            suffix = source_file.suffix.lower()

            if suffix in AUDIO_EXTENSIONS:
                # Logic: Transcode if file is missing OR if configuration changed for this tree
                needs_transcode = False
                
                if not dest_file.exists():
                    needs_transcode = True
                elif is_file_in_dirty_scope(source_file, dirty_scopes):
                    needs_transcode = True
                
                if needs_transcode:
                    volume_reduce = get_transcode_settings(source_file, SOURCE_ROOT)
                    transcode_file(source_file, dest_file, volume_reduce)
                    processed_files_count += 1
            
            elif suffix in IMAGE_EXTENSIONS or file_name.lower() in ['cover.jpg', 'folder.png']:
                # For images, simple overwrite if missing or newer could be added, 
                # but requirements imply mirroring assets.
                if not dest_file.exists():
                     shutil.copy2(source_file, dest_file)
                     processed_files_count += 1
        if MAX_FILES_TO_PROCESS is not None and processed_files_count >= MAX_FILES_TO_PROCESS:
            break

    # 4. Update Cache (Only after processing is done)
    if dirty_scopes:
        update_cache(dirty_scopes)
        cleanup_changed_files(dirty_scopes)

if __name__ == "__main__":
    process_library()
