#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "pyyaml",
# ]
# ///
"""
Script Requirements:
- As a user, I want to read a YAML configuration file located at '$HOME/code/notes/linked-notes.yml'.
- As a user, I want to define destination directories for specific configuration keys using a dictionary.
- As a user, I want to read `linkedNotes` patterns to create hard links from Source -> Destination.
- As a user, I want to read `exemptFiles` patterns to prevent specific files in the Destination from being deleted.
- As a user, I want to ensure that ONLY files with the `.md` extension are ever candidates for deletion in the Destination.
- As a user, I want existing hard links to be preserved without error.
- As a user, I want to ensure no files are ever deleted from the source directory.
"""

import os
import sys
import yaml
from pathlib import Path

# --- Configuration ---

HOME = Path.home()
SOURCE_DIR = HOME / "code/notes"
CONFIG_FILE = SOURCE_DIR / "linked-notes.yml"

# User-editable dictionary mapping YAML keys to Destination Directories
DEST_MAPPINGS = {
    "silverbullet": HOME / ".local/notes/silverbullet",
}

# ---------------------

def load_config(path: Path) -> dict:
    if not path.exists():
        print(f"Error: Configuration file not found at {path}")
        sys.exit(1)
    
    with open(path, 'r') as f:
        return yaml.safe_load(f) or {}

def sync_links():
    print(f"Starting sync from {SOURCE_DIR}")
    config = load_config(CONFIG_FILE)

    for key, dest_str in DEST_MAPPINGS.items():
        dest_dir = Path(dest_str)
        
        # Parse the section config
        section_data = config.get(key) or {}
        
        # Handle cases where section might be empty or malformed
        if not isinstance(section_data, dict):
            print(f"Warning: Configuration for '{key}' is not a valid dictionary. Skipping.")
            continue

        linked_patterns = section_data.get('linkedNotes') or []
        exempt_patterns = section_data.get('exemptFiles') or []

        print(f"--- Processing key: '{key}' ---")
        print(f"Destination: {dest_dir}")

        if not dest_dir.exists():
            print(f"Creating directory: {dest_dir}")
            dest_dir.mkdir(parents=True, exist_ok=True)

        # 1. Expand Globs and Create/Verify Hard Links
        allowed_dest_files = set()

        for pattern in linked_patterns:
            matched_files = list(SOURCE_DIR.glob(pattern))
            
            if not matched_files:
                # Optional: Verbose logging could go here
                continue

            for source_file in matched_files:
                if not source_file.is_file():
                    continue

                rel_path = source_file.relative_to(SOURCE_DIR)
                dest_file = dest_dir / rel_path
                
                allowed_dest_files.add(dest_file)

                if not dest_file.parent.exists():
                    dest_file.parent.mkdir(parents=True, exist_ok=True)

                if dest_file.exists():
                    if dest_file.stat().st_ino == source_file.stat().st_ino:
                        pass 
                    else:
                        print(f"Relinking (target differed): {rel_path}")
                        dest_file.unlink()
                        os.link(source_file, dest_file)
                else:
                    print(f"Linking: {rel_path}")
                    os.link(source_file, dest_file)

        # 2. Cleanup Dangling Files in Destination
        if dest_dir == SOURCE_DIR:
            print("Error: Destination cannot be Source. Skipping cleanup.")
            continue

        print("Checking for files to cleanup...")
        for path in dest_dir.rglob('*'):
            if not path.is_file():
                continue

            # Rule 1: Only prune markdown files
            if path.suffix != '.md':
                continue

            # Rule 2: Keep files we just verified/linked
            if path in allowed_dest_files:
                continue

            # Rule 3: Check Exemptions
            # We match the path relative to the destination directory against the exempt patterns
            rel_path = path.relative_to(dest_dir)
            is_exempt = False
            for exempt_pattern in exempt_patterns:
                if rel_path.match(exempt_pattern):
                    is_exempt = True
                    break
            
            if is_exempt:
                print(f"Skipping exempt file: {path.name}")
                continue

            # If we reached here, the file is an unlinked .md file that is not exempt
            print(f"Removing unlisted file: {path}")
            path.unlink()

    print("--- Sync Complete ---")

if __name__ == "__main__":
    sync_links()
