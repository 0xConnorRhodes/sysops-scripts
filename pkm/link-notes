#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#   "pyyaml",
# ]
# ///
"""
Script Requirements:
- As a user, I want the script to check the current machine's hostname and only proceed if it matches a defined allowlist (e.g., 'mpro').
- As a user, I want to read a YAML configuration file located at '$HOME/code/notes/linked-notes.yml'.
- As a user, I want to define destination directories for specific configuration keys using a dictionary.
- As a user, I want to read `linkedNotes` patterns to sync files by comparing modification times.
- As a user, I want files to be synchronized so that the newer version overwrites the older one in both directories.
- As a user, I want markup characters (=text=) to be replaced with backticks (`text`) when syncing file contents.
- As a user, I want to read `exemptFiles` patterns to prevent specific files in the Destination from being deleted.
- As a user, I want to ensure that ONLY files with the `.md` extension are ever candidates for deletion in the Destination.
- As a user, I want to ensure no files are ever deleted from the source directory.
"""

import os
import sys
import yaml
import socket
import shutil
import re
from pathlib import Path

# --- Configuration ---

HOME = Path.home()
SOURCE_DIR = HOME / "code/notes"
CONFIG_FILE = SOURCE_DIR / "linked-notes.yml"

# Hostname Allowlist
RUN_ON = ["mpro"]

# User-editable dictionary mapping YAML keys to Destination Directories
DEST_MAPPINGS = {
    "silverbullet": HOME / ".local/notes/silverbullet",
    "myflatnotes": HOME / ".local/notes/myflatnotes",
}

# ---------------------

def check_hostname():
    current_host = socket.gethostname()
    if current_host not in RUN_ON:
        print(f"Skipping: Current host '{current_host}' is not in the allowed list {RUN_ON}.")
        sys.exit(0)
    print(f"Host check passed: {current_host}")

def load_config(path: Path) -> dict:
    if not path.exists():
        print(f"Error: Configuration file not found at {path}")
        sys.exit(1)

    with open(path, 'r') as f:
        return yaml.safe_load(f) or {}

def replace_markup(content: str) -> str:
    """Replace =text= markup with `text` backticks."""
    return re.sub(r'=([^=\n]+)=', r'`\1`', content)

def copy_with_markup_replacement(source_file: Path, dest_file: Path):
    """Copy file from source to destination, replacing markup characters."""
    with open(source_file, 'r', encoding='utf-8') as f:
        content = f.read()

    transformed_content = replace_markup(content)

    with open(dest_file, 'w', encoding='utf-8') as f:
        f.write(transformed_content)

    # Preserve modification time
    shutil.copystat(source_file, dest_file)

def sync_links():
    check_hostname()

    print(f"Starting sync from {SOURCE_DIR}")
    config = load_config(CONFIG_FILE)

    for key, dest_str in DEST_MAPPINGS.items():
        dest_dir = Path(dest_str)

        section_data = config.get(key) or {}

        if not isinstance(section_data, dict):
            print(f"Warning: Configuration for '{key}' is not a valid dictionary. Skipping.")
            continue

        linked_patterns = section_data.get('linkedNotes') or []
        exempt_patterns = section_data.get('exemptFiles') or []

        print(f"--- Processing key: '{key}' ---")
        print(f"Destination: {dest_dir}")

        if not dest_dir.exists():
            print(f"Creating directory: {dest_dir}")
            dest_dir.mkdir(parents=True, exist_ok=True)

        # 1. Expand Globs and Sync Files Based on Modification Time
        allowed_dest_files = set()

        for pattern in linked_patterns:
            matched_files = list(SOURCE_DIR.glob(pattern))

            if not matched_files:
                continue

            for source_file in matched_files:
                if not source_file.is_file():
                    continue

                rel_path = source_file.relative_to(SOURCE_DIR)
                dest_file = dest_dir / rel_path

                allowed_dest_files.add(dest_file)

                if not dest_file.parent.exists():
                    dest_file.parent.mkdir(parents=True, exist_ok=True)

                if dest_file.exists():
                    source_mtime = source_file.stat().st_mtime
                    dest_mtime = dest_file.stat().st_mtime

                    if source_mtime > dest_mtime:
                        print(f"Updating destination (source is newer): {rel_path}")
                        copy_with_markup_replacement(source_file, dest_file)
                    elif dest_mtime > source_mtime:
                        print(f"Updating source (destination is newer): {rel_path}")
                        # When copying from destination to source, we need to reverse the markup replacement
                        with open(dest_file, 'r', encoding='utf-8') as f:
                            content = f.read()
                        # Replace backticks with =text= markup
                        reversed_content = re.sub(r'`([^`\n]+)`', r'=\1=', content)
                        with open(source_file, 'w', encoding='utf-8') as f:
                            f.write(reversed_content)
                        shutil.copystat(dest_file, source_file)
                    # If times are equal, no action needed
                else:
                    print(f"Copying to destination: {rel_path}")
                    copy_with_markup_replacement(source_file, dest_file)

        # 2. Cleanup Dangling Files in Destination
        if dest_dir == SOURCE_DIR:
            print("Error: Destination cannot be Source. Skipping cleanup.")
            continue

        print("Checking for files to cleanup...")
        for path in dest_dir.rglob('*'):
            if not path.is_file():
                continue

            # Rule 1: Only prune markdown files
            if path.suffix != '.md':
                continue

            # Rule 2: Keep files we just verified/linked
            if path in allowed_dest_files:
                continue

            # Rule 3: Check Exemptions
            rel_path = path.relative_to(dest_dir)
            is_exempt = False
            for exempt_pattern in exempt_patterns:
                if rel_path.match(exempt_pattern):
                    is_exempt = True
                    break

            if is_exempt:
                print(f"Skipping exempt file: {path.name}")
                continue

            print(f"Removing unlisted file: {path}")
            path.unlink()

    print("--- Sync Complete ---")

if __name__ == "__main__":
    sync_links()
