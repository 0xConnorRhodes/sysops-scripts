#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
# ]
# ///
"""
Script Requirements:
- As a user, I want to scan all .md files in '~/code/notes' and its subdirectories.
- As a user, I want to find files that contain the exact string "#hh".
- As a user, I want to create a hardlink for any matching file in '~/.local/notes/housenotes/'.
- As a user, if a matching file is in '~/code/notes/df', I want the hardlink's name to be a lowercase, kebab-case version of its H1 header (e.g., 'my-header.md').
- As a user, if a matching file in '~/code/notes/df' has no H1 header, I want a warning printed to stderr, and the script should continue.
- As a user, I want to see print output for files that were processed, showing both newly created hardlinks and files that were already linked.
- As a user, I want warnings and errors printed to stderr.
- As a user, if any of the hardlinked files have been removed from '~/code/notes', I want the corresponding file in '~/.local/notes/housenotes/' to be deleted.

PLACE

- just added hardlink cleanup.
- try running the update-zk script to delete the letter to tate, then verify that this script prunes it
- then add calling this script into the update-zk script
"""

import sys
import re
from pathlib import Path

# --- Configuration ---

SOURCE_DIR = Path.home() / "code" / "notes"
DF_DIR = SOURCE_DIR / "df"
TARGET_DIR = Path.home() / ".local" / "notes" / "housenotes"
SEARCH_STRING = "#hh"
H1_REGEX = re.compile(r"^\s*#\s+(.+)\s*$", re.MULTILINE)

# --- --- ---

def get_h1_filename(content: str) -> str | None:
    """Finds the first H1 header and returns a slugified filename."""
    match = H1_REGEX.search(content)
    if not match:
        return None

    header_text = match.group(1).strip()
    return header_text.lower().replace(" ", "-") + ".md"

def cleanup_orphaned_hardlinks():
    """
    Remove hardlinks in the target directory whose source files no longer exist.
    """
    if not TARGET_DIR.exists():
        return

    for target_file in TARGET_DIR.iterdir():
        if not target_file.is_file():
            continue

        try:
            # Check if the file is a hardlink by seeing if it has multiple links
            stat_info = target_file.stat()
            if stat_info.st_nlink <= 1:
                continue

            # For hardlinks, we need to check if the source still exists in SOURCE_DIR
            # We'll do this by checking if any file in SOURCE_DIR has the same inode
            source_exists = False
            target_inode = stat_info.st_ino

            for source_file in SOURCE_DIR.rglob("*.md"):
                try:
                    if source_file.stat().st_ino == target_inode:
                        source_exists = True
                        break
                except (OSError, IOError):
                    # Source file might be inaccessible, continue checking others
                    continue

            if not source_exists:
                # No matching source file found, remove the orphaned hardlink
                target_file.unlink()
                print(f"Removed orphaned hardlink: {target_file}")

        except (OSError, IOError) as e:
            print(f"Error checking hardlink '{target_file}': {e}", file=sys.stderr)

def process_file(source_file: Path):
    """
    Checks a file for the search string and creates a hardlink
    if found, applying special 'df' folder naming rules.
    """
    try:
        content = source_file.read_text(encoding="utf-8")

        if SEARCH_STRING not in content:
            return

        target_file_name = ""

        # Check for special 'df' directory case
        if source_file.parent == DF_DIR:
            target_file_name = get_h1_filename(content)
            if not target_file_name:
                # Warn and skip this file, but continue script
                print(
                    f"Warning: File '{source_file}' contains '{SEARCH_STRING}' "
                    "but has no H1 header. Skipping.",
                    file=sys.stderr
                )
                return
        else:
            # Standard case: use the original filename
            target_file_name = source_file.name

        target_path = TARGET_DIR / target_file_name

        # Handle existing files to be idempotent
        if target_path.exists():
            if target_path.samefile(source_file):
                print(f"Already linked: {source_file} -> {target_path}")
                return # Already linked correctly, silent success
            else:
                # Name collision with a *different* file
                print(
                    f"Error: Target '{target_path}' already exists but points "
                    f"to a different file. Cannot link '{source_file}'.",
                    file=sys.stderr
                )
                return

        # Create the hardlink
        target_path.hardlink_to(source_file)
        print(f"Created hardlink: {source_file} -> {target_path}")

    except (IOError, OSError, UnicodeDecodeError) as e:
        print(f"Error processing file '{source_file}': {e}", file=sys.stderr)
    except Exception as e:
        print(
            f"An unexpected error occurred with file '{source_file}': {e}",
            file=sys.stderr
        )

def main():
    if not SOURCE_DIR.is_dir():
        print(f"Error: Source directory not found: {SOURCE_DIR}", file=sys.stderr)
        sys.exit(1)

    # Ensure target directory exists
    TARGET_DIR.mkdir(parents=True, exist_ok=True)

    # Clean up orphaned hardlinks first
    cleanup_orphaned_hardlinks()

    # Recursively find all .md files and process them
    for md_file in SOURCE_DIR.rglob("*.md"):
        process_file(md_file)

if __name__ == "__main__":
    main()
