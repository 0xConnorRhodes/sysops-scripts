#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = ["PyYAML"]
# ///
"""
Script Requirements:
- As a user, I want to provide an audio file path as a CLI argument.
- As a user, I want to open a Neovim buffer pre-populated with existing metadata.
- As a user, I want the script to auto-detect 'cover.jpg' or 'cover.png' and apply it.
- As a user, I want the script to read metadata from a 'meta.yml' file in the same directory if it exists.
- As a user, I want the script to populate fields from 'meta.yml' when the existing file metadata is blank.
- As a user, I want the script to prioritize existing file metadata over 'meta.yml' when both are present.
- As a user, I want the script to auto-populate the Track Name with the file basename (without extension) when it's blank.
- As a user, I want the script to overwrite the existing file with new metadata.
- As a user, I want the script to create an empty '.changed' file in the directory ONLY if metadata was actually modified from the original file's metadata (not including auto-populated defaults).
"""

import sys
import os
import subprocess
import tempfile
import re
import yaml
from pathlib import Path
from typing import Dict, Optional

# --- Configuration & Constants ---

EDITOR = "nvim"

METADATA_MAP = {
    "Track Name": "©nam",
    "Artist": "©ART",
    "Album": "©alb",
}

ATOM_TO_READABLE = {v: k for k, v in METADATA_MAP.items()}

# --- Protocol / Base Logic ---

def get_artwork_path(audio_file_path: Path) -> Optional[Path]:
    parent_dir = audio_file_path.parent
    for ext in ['.jpg', '.png']:
        cover = parent_dir / f"cover{ext}"
        if cover.exists():
            return cover
    return None

def read_meta_yaml(audio_file_path: Path) -> Dict[str, str]:
    """Read metadata from meta.yml file in the same directory as the audio file."""
    meta_file = audio_file_path.parent / "meta.yml"
    if not meta_file.exists():
        return {}

    try:
        with open(meta_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)

        if not data or 'metadata' not in data:
            return {}

        metadata = data['metadata']
        # Only return fields that are in our METADATA_MAP
        return {
            key: str(value) for key, value in metadata.items()
            if key in METADATA_MAP
        }
    except (yaml.YAMLError, IOError, UnicodeDecodeError):
        # If there's any error reading the YAML file, return empty dict
        return {}

def parse_buffer(content: str) -> Dict[str, str]:
    data = {}
    for line in content.splitlines():
        if ": " in line:
            key, val = line.split(": ", 1)
            data[key.strip()] = val.strip()
    return data

def edit_in_neovim(initial_data: Dict[str, str]) -> Dict[str, str]:
    with tempfile.NamedTemporaryFile(mode='w+', suffix=".tmp", delete=False) as tf:
        for key in METADATA_MAP.keys():
            val = initial_data.get(key, "")
            tf.write(f"{key}: {val}\n")
        temp_path = tf.name

    try:
        subprocess.call([EDITOR, temp_path])
        with open(temp_path, 'r') as tf:
            content = tf.read()
    finally:
        os.remove(temp_path)

    return parse_buffer(content)

# --- Format Specific Handlers ---

class M4AHandler:
    @staticmethod
    def read(path: Path) -> Dict[str, str]:
        cmd = ["AtomicParsley", str(path), "-t"]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        data = {}
        pattern = re.compile(r'Atom "(?P<atom>[^"]+)" contains: (?P<val>.*)')
        
        for line in result.stdout.splitlines():
            match = pattern.search(line)
            if match:
                atom = match.group("atom")
                val = match.group("val")
                if atom in ATOM_TO_READABLE:
                    data[ATOM_TO_READABLE[atom]] = val
        return data

    @staticmethod
    def write(path: Path, metadata: Dict[str, str]):
        cmd = ["AtomicParsley", str(path), "--overWrite"]
        
        if "Track Name" in metadata:
            cmd.extend(["--title", metadata["Track Name"]])
        if "Artist" in metadata:
            cmd.extend(["--artist", metadata["Artist"]])
        if "Album" in metadata:
            cmd.extend(["--album", metadata["Album"]])
            
        artwork = get_artwork_path(path)
        if artwork:
            cmd.extend(["--artwork", str(artwork)])
            
        subprocess.run(cmd, check=True)

# --- Main Dispatcher ---

HANDLERS = {
    ".m4a": M4AHandler
}

def main():
    if len(sys.argv) < 2:
        print("Usage: edit-metadata <path_to_audio_file>")
        sys.exit(1)

    file_path = Path(sys.argv[1]).resolve()
    
    if not file_path.exists():
        print(f"Error: File '{file_path}' not found.")
        sys.exit(1)

    handler = HANDLERS.get(file_path.suffix.lower())
    
    if not handler:
        print(f"Error: Unsupported file format '{file_path.suffix}'. Only .m4a is currently supported.")
        sys.exit(1)

    # 1. Read existing metadata
    current_data = handler.read(file_path)

    # 1.5. Read metadata from meta.yml and merge with existing data
    meta_yaml_data = read_meta_yaml(file_path)

    # For each field, prefer existing data if present, otherwise use meta.yml data
    # Special case for Track Name: use file basename if no existing data or meta.yml data
    merged_data = {}
    for field_name in METADATA_MAP.keys():
        if current_data.get(field_name):
            merged_data[field_name] = current_data[field_name]
        elif meta_yaml_data.get(field_name):
            merged_data[field_name] = meta_yaml_data[field_name]
        elif field_name == "Track Name":
            # Auto-populate Track Name with file basename (without extension)
            merged_data[field_name] = file_path.stem
        else:
            merged_data[field_name] = ""

    # 2. Edit in Neovim with merged data
    new_data = edit_in_neovim(merged_data)

    # 3. Check for changes before writing
    # We compare against the original file metadata to detect actual user edits
    if new_data == current_data:
        print("No changes detected in metadata. Exiting.")
        return

    # 4. Write updates
    print(f"Updating {file_path.name}...")
    handler.write(file_path, new_data)
    
    # 5. Create .changed indicator
    changed_marker = file_path.parent / ".changed"
    changed_marker.touch()
    print(f"Success. Created marker: {changed_marker}")

if __name__ == "__main__":
    main()
