#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///
"""
Script Requirements:
- As a user, I want to specify an input video file for processing.
- As a user, I want to define crop values for the left, right, top, and bottom edges using -l, -r, -t, and -b flags.
- As a user, I want the script to re-encode the video with actual cropping applied.
- As a user, I want the script to preserve audio quality while re-encoding video.
- As a user, I want the script to generate an output file with a suffix to avoid overwriting the original.
"""

import argparse
import subprocess
import sys
import shutil
from pathlib import Path

def check_ffmpeg_installed():
    if not shutil.which("ffmpeg") or not shutil.which("ffprobe"):
        print("Error: ffmpeg and ffprobe must be installed and in your PATH.")
        sys.exit(1)

def get_video_dimensions(input_path: Path) -> tuple[int, int]:
    """Get the width and height of the input video."""
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "v:0",
        "-show_entries", "stream=width,height",
        "-of", "csv=p=0",
        str(input_path)
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        width, height = map(int, result.stdout.strip().split(','))
        return width, height
    except (subprocess.CalledProcessError, ValueError):
        print(f"Error: Could not determine video dimensions for {input_path}")
        sys.exit(1)

def build_crop_filter(args: argparse.Namespace, width: int, height: int) -> str:
    """Build the crop filter string based on crop values."""
    new_width = width - args.left - args.right
    new_height = height - args.top - args.bottom

    if new_width <= 0 or new_height <= 0:
        print("Error: Crop values would result in invalid dimensions.")
        sys.exit(1)

    return f"crop={new_width}:{new_height}:{args.left}:{args.top}"

def main():
    parser = argparse.ArgumentParser(description="Crop video with re-encoding.")
    parser.add_argument("input_file", type=Path, help="Path to input video file")
    parser.add_argument("-l", "--left", type=int, default=0, help="Pixels to crop from left")
    parser.add_argument("-r", "--right", type=int, default=0, help="Pixels to crop from right")
    parser.add_argument("-t", "--top", type=int, default=0, help="Pixels to crop from top")
    parser.add_argument("-b", "--bottom", type=int, default=0, help="Pixels to crop from bottom")
    parser.add_argument("-c", "--codec", type=str, default="libx264", help="Video codec to use for re-encoding (default: libx264)")
    parser.add_argument("-crf", type=int, default=23, help="CRF quality level (lower = better quality, default: 23)")

    args = parser.parse_args()

    if not args.input_file.exists():
        print(f"Error: File '{args.input_file}' not found.")
        sys.exit(1)

    if args.left == 0 and args.right == 0 and args.top == 0 and args.bottom == 0:
        print("Error: No crop values specified.")
        sys.exit(1)

    check_ffmpeg_installed()

    width, height = get_video_dimensions(args.input_file)
    crop_filter = build_crop_filter(args, width, height)

    output_file = args.input_file.with_stem(f"{args.input_file.stem}_cropped")

    cmd = [
        "ffmpeg",
        "-i", str(args.input_file),
        "-c:v", args.codec,    # Re-encode video with specified codec
        "-crf", str(args.crf), # Set quality
        "-c:a", "copy",        # Copy audio without re-encoding
        "-vf", crop_filter,    # Apply crop filter
        "-y",                  # Overwrite output if exists
        str(output_file)
    ]

    print(f"Processing '{args.input_file}' ({width}x{height})...")
    print(f"Cropping filter: {crop_filter}")
    print(f"Using codec: {args.codec} (CRF: {args.crf})")
    subprocess.run(cmd, check=True)
    print(f"Success: Output saved to '{output_file}'")

if __name__ == "__main__":
    main()
