#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///
"""
Script Requirements:
- As a user, I want to specify an input video file for processing.
- As a user, I want to define crop values for the left, right, top, and bottom edges using -l, -r, -t, and -b flags.
- As a user, I want the script to automatically detect if the input video is H.264 or HEVC.
- As a user, I want the script to apply a bitstream filter to modify crop metadata without re-encoding video or audio.
- As a user, I want the script to generate an output file with a suffix to avoid overwriting the original.
"""

import argparse
import subprocess
import sys
import json
import shutil
from pathlib import Path

def check_ffmpeg_installed():
    if not shutil.which("ffmpeg") or not shutil.which("ffprobe"):
        print("Error: ffmpeg and ffprobe must be installed and in your PATH.")
        sys.exit(1)

def get_video_codec(input_path: Path) -> str:
    cmd = [
        "ffprobe",
        "-v", "error",
        "-select_streams", "v:0",
        "-show_entries", "stream=codec_name",
        "-of", "json",
        str(input_path)
    ]
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        data = json.loads(result.stdout)
        return data["streams"][0]["codec_name"]
    except (subprocess.CalledProcessError, IndexError, KeyError, json.JSONDecodeError):
        print(f"Error: Could not determine codec for {input_path}")
        sys.exit(1)

def build_bsf_string(codec: str, args: argparse.Namespace) -> str:
    filter_map = {
        "h264": "h264_metadata",
        "hevc": "hevc_metadata"
    }
    
    bsf_name = filter_map.get(codec)
    if not bsf_name:
        print(f"Error: Codec '{codec}' does not support metadata cropping via FFmpeg bitstream filters.")
        print("Supported codecs: h264, hevc")
        sys.exit(1)

    options = []
    if args.left > 0:
        options.append(f"crop_left={args.left}")
    if args.right > 0:
        options.append(f"crop_right={args.right}")
    if args.top > 0:
        options.append(f"crop_top={args.top}")
    if args.bottom > 0:
        options.append(f"crop_bottom={args.bottom}")

    if not options:
        print("Error: No crop values specified.")
        sys.exit(1)

    return f"{bsf_name}={':'.join(options)}"

def main():
    parser = argparse.ArgumentParser(description="Crop video metadata without re-encoding.")
    parser.add_argument("input_file", type=Path, help="Path to input video file")
    parser.add_argument("-l", "--left", type=int, default=0, help="Pixels to crop from left")
    parser.add_argument("-r", "--right", type=int, default=0, help="Pixels to crop from right")
    parser.add_argument("-t", "--top", type=int, default=0, help="Pixels to crop from top")
    parser.add_argument("-b", "--bottom", type=int, default=0, help="Pixels to crop from bottom")

    args = parser.parse_args()

    if not args.input_file.exists():
        print(f"Error: File '{args.input_file}' not found.")
        sys.exit(1)

    check_ffmpeg_installed()
    
    codec = get_video_codec(args.input_file)
    bsf_string = build_bsf_string(codec, args)
    
    output_file = args.input_file.with_stem(f"{args.input_file.stem}_cropped")
    
    cmd = [
        "ffmpeg",
        "-i", str(args.input_file),
        "-c", "copy",          # Copy all streams (video/audio/subs)
        "-bsf:v", bsf_string,  # Apply bitstream filter to video
        "-y",                  # Overwrite output if exists (optional, mostly for script reliability)
        str(output_file)
    ]

    print(f"Processing '{args.input_file}' (Codec: {codec})...")
    subprocess.run(cmd, check=True)
    print(f"Success: Output saved to '{output_file}'")

if __name__ == "__main__":
    main()
